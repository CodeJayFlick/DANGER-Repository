"""
This script cleans data generated by generate_ai_data.py. For each file in input_folder's about_samples.csv,
a new file in output_folder is created, with only the Python code added.

Parameters:
- input_folder - The folder to read code from
- output_folder - The folder to write to

Notes:

Parsing is done by extracting the code from the first code block (as originally used, there is generally only one code block).

If the file cannot be parsed (eg has no Python code block), it will be skipped.

A new about_samples.csv will be created in output_folder. It will be identical to the one in input_folder, except
scripts that could not be parsed will not be included.
"""

import os
import csv
import constants

# Parameters Start

input_folder = "py_from_java_lambda_attempt_2"
output_folder = "cleaned_ai_data_7"

# Parameters End

print("Parameters used by this script: ")
print(f"Input Folder: {input_folder}")
print(f"Output Folder: {output_folder}")

def end_of_path(input_path: str):
    return input_path[max(input_path.rfind("/"), input_path.rfind("\\")) + 1:]

def parse_with_start_line_and_end_line(script: str, start_line: str, end_line: str) -> str | None:
    """
    Given the parameters, finds the first instance of start_line followed by end_line (each on their own lines).
    Then, returns the text in-between.
    This check will not be case-sensitive.

    If there are no such instances, returns None.
    """
    lines = script.split("\n")
    result = ''
    started_script = False
    for line in lines:
        if not started_script and line.lower() != start_line.lower():
            pass
        elif not started_script and line.lower() == start_line.lower():
            started_script = True
        elif line.lower() != end_line.lower():
            result += line + "\n"
        else:
            return result
    return None

def parse_script(script: str) -> str | None:
    possible_result = parse_with_start_line_and_end_line(script, start_line="```Python", end_line="```")
    if possible_result:
        return possible_result
    possible_result = parse_with_start_line_and_end_line(script, start_line="```", end_line="```")
    if possible_result:
        return possible_result
    return None


if os.path.isdir(output_folder) and len(os.listdir(output_folder)) != 0:
    exit(f"{output_folder} exists and is not empty. Exiting script.")

if not os.path.isdir(output_folder):
    os.mkdir(output_folder)

old_about_samples_file = open(os.path.join(input_folder, constants.CSV_PATH_NAME), 'r')
old_about_samples_csv = csv.reader(old_about_samples_file)

new_about_samples_file = open(os.path.join(output_folder, constants.CSV_PATH_NAME), 'w', newline='')
new_about_samples_csv = csv.writer(new_about_samples_file)
new_about_samples_csv.writerow(["Filename", "AI", "Comments"])

old_about_samples_csv.__next__() # skip first row
for row in old_about_samples_csv:
    filename = end_of_path(row[0])
    is_ai = row[1]
    source = row[2]

    if filename.lower() == constants.CSV_PATH_NAME: # should never happen but just in case
        continue
    # print(f"Starting {filename}.")

    old_file = open(os.path.join(input_folder, filename) , 'r')
    new_file = open(os.path.join(output_folder, filename), 'w')
    try:
        old_file_text = old_file.read()
        parsed_script = parse_script(old_file_text)
        if parsed_script:
            new_file.write(parsed_script)
            new_about_samples_csv.writerow([filename, is_ai, source])
            new_about_samples_file.flush()
        else:
            print(f"Script with filename {filename} could not be parsed. Skipping")
    except:
        print(f"Ran into error when converting {filename}. Skipping.")
