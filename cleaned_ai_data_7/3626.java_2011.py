class DataPlugin:
    def __init__(self):
        self.dtm_service = None
        self.settings_action = None
        self.default_settings_action = None
        self.edit_data_type_action = None
        self.create_structure_action = None
        self.create_array_action = None
        self.rename_data_field_action = None
        self.pointer_action = None
        self.recently_used_action = None
        self.favorite_actions = []

    def addActions(self):
        # Add actions here

    def initializeServices(self):
        if not hasattr(self, 'dtm_service'):
            raise Exception("DataTypeManagerService was not found!")
        self.dtm_service.add_data_type_manager_listener(adapter)

    def getEditableDataTypeFromContext(self, context):
        selection = context.get_selection()
        program = context.get_program()
        data = None
        if selection and not selection.is_empty():
            listing = program.get_listing()
            is_data_only = not listing.instructions(selection).has_next()
            if is_data_only:
                data = self.getDataUnit(context)
            else:
                # Add code here

    def getEditableDataType(self, data):
        base_dt = data.get_base_data_type()
        return dtm_service.is_editable(base_dt)

    def createData(self, dt, context, enable_conflict_handling=False):
        if not hasattr(dt, 'clone'):
            raise Exception("Invalid data type!")
        program_location = context.get_location()
        start_address = None
        selection = None

        # Add code here

    def doCreateData(self, context, dt):
        selection = context.get_selection()
        location = context.get_location()

        if not hasattr(dt, 'clone'):
            raise Exception("Invalid data type!")

        return self.create_data_for_selection(program, dt, selection)

    def createDataForSelection(self, program, dt, selection):
        background_command = None
        start_address = None

        # Add code here

    def updateRecentlyUsed(self, dt):
        if hasattr(self.dtm_service, 'set_recently_used'):
            self.dtm_service.set_recently_used(dt)

    def dataSettingsCallback(self, context):
        dialog = None

        data = self.getDataUnit(context)
        selection = context.get_selection()
        program = context.get_program()

        # Add code here

    def editDataTypeCallback(self, context):
        if not hasattr(data, 'get_base_data_type'):
            raise Exception("Invalid data type!")

        return dtm_service.edit(dt)

    @staticmethod
    def getDataUnit(program, start_address, component_path=None):
        if start_address is None:
            return None

        data = program.get_listing().data_containing(start_address)
        if data is None or len(data.components) <= 0:
            return data

        comp_data = data.component(component_path)

        return comp_data if comp_data else data
