class OatHeaderAnalyzer:
    def __init__(self):
        pass

    def get_name(self):
        return "Android OAT Header Format"

    def get_default_enablement(self, program):
        return True

    def get_description(self):
        return "Analyzes the Android OAT sections (oatdata and oatexec) in this program."

    def can_analyze(self, program):
        if not OatConstants.isOAT(program):
            return False
        else:
            return True

    def is_prototype(self):
        return True

    def analyze(self, program, set, monitor, log):
        self.clear_if_needed(program, monitor, log)

        oat_data_symbol = OatUtilities.get_oat_data_symbol(program)
        address = oat_data_symbol.get_address()

        reader = OatUtilities.get_binary_reader(program)
        if not reader:
            return False

        oat_header = None
        try:
            oat_header = OatHeaderFactory.new_oat_header(reader)

            OatHeaderFactory.parse_oat_header(oat_header, program, reader, monitor, log)
        except UnsupportedOATVersionException as e:
            log.append_msg(e.get_message())
            return False

        try:
            header_data_type = oat_header.to_data_type()
            data = self.create_data(program, address, header_data_type)
            address += header_data_type.get_length()

            self.markup_class_offsets(program, oat_data_symbol, oat_header, data, monitor, log)

            monitor.set_message("Applying OAT DEX headers...")
            monitor.initialize(len(oat_header.oat_dex_file_list))
            for i in range(len(oat_header.oat_dex_file_list)):
                monitor.check_cancelled()
                monitor.increment_progress(1)
                oatdexfileheader = oat_header.get_oat_dex_file_list()[i]
                oatdexfileheader.markup(oat_header, program, monitor, log)

                self.apply_dex_header(program, oatdexfileheader, oat_data_symbol, i)

            self.markup_oat_patches(program, oat_header, monitor, log)
        except Exception as e:
            raise e
        finally:
            oat_header = None

    def clear_if_needed(self, program, monitor, log):
        oatdata_symbol = OatUtilities.get_oat_data_symbol(program)
        data = program.get_listing().get_defined_data_at(oatdata_symbol.get_address())
        if data and isinstance(data, list) and len(data[0].get_base_type()) == 1:
            program.get_listing().clear_code_units(oatdata_symbol.get_address(), oatdata_symbol.get_max_address(), False)

    def markup_oat_patches(self, program, oat_header, monitor, log):
        monitor.set_message("Annotating OAT Patches...")
        memory = program.get_memory()

        if oat_header.get_version() == OatConstants.VERSION_LOLLIPOP_MR1_FI_RELEASE:
            block = memory.get_block(OatConstants.DOT_OAT_PATCHES_SECTION_NAME)
            destination_block = self.find_oat_patches_destination_block(program, block)

            if not block or not destination_block:
                log.append_msg("Could not locate OAT patches source/destination block.")
                return

            data_type = DWordDataType()
            monitor.set_progress(0)
            number_of_elements = len(block) // data_type.get_length()
            monitor.set_maximum(number_of_elements)

            for i in range(number_of_elements):
                monitor.check_cancelled()
                address = block.get_start().add(i * data_type.get_length())
                data = self.create_data(program, address, data_type)
                scalar = data[0]
                to_addr = destination_block.get_start().add(scalar.get_unsigned_value())
                program.get_listing().set_comment(address, CodeUnit.EOL_COMMENT, "->" + str(to_addr))

    def find_oat_patches_destination_block(self, program, block):
        pos = block.name.index(OatConstants.DOT_OAT_PATCHES_SECTION_NAME)
        if pos == 0:
            return program.get_memory().get_block(ElfSectionHeaderConstants.dot_text)

        destination_block_name = block.name[:pos]
        return program.get_memory().get_block(destination_block_name)

    def apply_dex_header(self, program, oatdexfileheader, oat_data_symbol, index):
        address = oat_data_symbol.get_address() + oatdexfileheader.dex_file_offset

        dex_header = oatdexfileheader.get DexHeader()
        if not dex_header:
            return

        data_type = dex_header.to Data Type
        try:
            data_type.name += "_" + str(index)
        except Exception as e:
            pass  # ignore exception

        self.create_data(program, address, data_type)

    def markup_class_offsets(self, program, oatdata_symbol, oatheader, headerdata, monitor, log):
        symbol_table = program.get Symbol Table()
        reference_manager = program.get Reference Manager()
        equate_table = program.get Equate Table()

        for i in range(len(headerdata)):
            if not (headerdata[i].get_field_name().endswith("_offset_") and
                    headerdata[i].get_scalar(0).get_unsigned_value() > 0):
                continue

            scalar = headerdata[i].get_scalar(0)
            to_addr = oat_data_symbol.get_address() + scalar.get_unsigned_value()
            to_addr = OatUtilities.adjust_for_thumb_as_needed(oatheader, program, to_addr, log)

            reference_manager.add_memory_reference(headerdata[i].min_address,
                                                     to_addr, RefType.DATA, SourceType.ANALYSIS, 0)
            try:
                symbol_table.create_label(to_addr, headerdata[i].get_field_name(), SourceType.ANALYSIS)

                self.disassemble_as_needed(program, to_addr)
            except Exception as e:
                pass  # ignore exception

    def disassemble_as_needed(self, program, address):
        if program.get_memory().contains(address) and \
           program.get_memory().get_block(address).is_execute():
            if not program.get_listing().is_undefined(address, address):
                cmd = DisassembleCommand(address, None, False)
                cmd.apply_to(program)

    def create_data(self, program, address, data_type):
        return [Data(program, address, data_type)]

