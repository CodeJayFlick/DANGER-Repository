class IsolatedEntrySubModel:
    ISOLATED_MODEL_NAME = "Isolated Entry"

    def __init__(self, program):
        super().__init__(program)

    def get_subroutine(self, m_start_addr, monitor=None):
        if not isinstance(monitor, object) or not hasattr(monitor, 'is_cancelled'):
            raise ValueError("monitor must be an object with is_cancelled method")

        # Create address list which contains all other entry points for this M-model sub
        code_block = self.model_m.get_code_block_at(m_start_addr)
        if code_block is None:
            return None

        start_addresses = [code_block]
        while len(start_addresses) > 0:
            current_address = start_addresses.pop()
            if not monitor.is_cancelled():
                break
            else:
                raise CancelledException()

            # Get basic block at the specified address 
            code_blocks = self.model_m.get_basic_block_model().get_code_blocks_containing(current_address)
            for code_block in code_blocks:
                if code_block is None or len(code_block) == 0:
                    continue

                start_addresses.extend([code_block])
                break
        else:
            return create_sub(start_addresses, m_start_addr)

    def get_name(self):
        return self.ISOLATED_MODEL_NAME


class CancelledException(Exception):
    pass
